<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Emote Wall Overlay</title>
    <style>
        body {
            background: transparent;
            overflow: hidden;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
        }

        .emote {
            position: absolute;
            will-change: transform, opacity;
            pointer-events: none;
        }
    </style>
    <style id="custom-css">
        /* CUSTOM_CSS_PLACEHOLDER */
    </style>
</head>

<body>
    <script>
        const CLIENT_ID = '__TWITCH_CLIENT_ID__';
        const APP_TOKEN = '__TWITCH_APP_TOKEN__';

        const ANIMATION_DURATION = 5000;
        const SPAWN_INTERVAL = 100;
        const MIN_SIZE = 32;
        const MAX_SIZE = 96;

        let ws;

        function normalizeEmotes(emotes) {
            if (!emotes || typeof emotes !== 'object') return [];
            const parts = [];
            Object.keys(emotes).forEach(id => {
                emotes[id].forEach(r => {
                    if (typeof r === 'string') {
                        const [s, e] = r.split('-').map(n => parseInt(n, 10));
                        if (!Number.isNaN(s) && !Number.isNaN(e)) parts.push({ id, start: s, end: e });
                    } else if (r && typeof r === 'object' && Number.isInteger(r.start) && Number.isInteger(r.end)) {
                        parts.push({ id, start: r.start, end: r.end });
                    }
                });
            });
            return parts;
        }

        function spawnEmote(url) {
            const img = document.createElement('img');
            img.src = url;
            img.className = 'emote';

            const startY = Math.random() * (window.innerHeight - 50);
            const startX = Math.random() * (window.innerWidth - 50);

            const randomFactor = Math.pow(Math.random(), 2);
            const size = MIN_SIZE + randomFactor * (MAX_SIZE - MIN_SIZE);
            img.style.width = `${size}px`;
            img.style.height = `${size}px`;

            img.style.left = `${startX}px`;
            img.style.top = `${startY}px`;

            const angle = Math.random() * 360;
            const distance = 200 + Math.random() * 300;
            const duration = ANIMATION_DURATION * (0.8 + Math.random() * 0.4);

            document.body.appendChild(img);

            const animation = img.animate([
                { transform: 'scale(0) translate(0, 0)', opacity: 0 },
                { transform: 'scale(1.2) translate(0, 0)', opacity: 1, offset: 0.1 },
                { transform: 'scale(1) translate(0, 0)', opacity: 1, offset: 0.8 },
                { transform: `scale(1) translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`, opacity: 0 }
            ], {
                duration: duration,
                easing: 'cubic-bezier(0.25, 1, 0.5, 1)'
            });

            animation.onfinish = () => img.remove();
        }

        function connectWebSocket() {
            const host = window.location.hostname;
            const port = new URL(document.URL).port;
            const wsUrl = `ws://${host}:${port}`;
            ws = new WebSocket(wsUrl);
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if ((data.type === 'config' || data.type === 'config-update') && data.widget === 'emote-wall') {
                    const cfg = data.config || data;
                    if (cfg.customCSS) {
                        const style = document.getElementById('custom-css');
                        if (style) style.textContent = cfg.customCSS;
                    }
                } else if (data.type === 'chat' && data.emotes) {
                    const emoteList = normalizeEmotes(data.emotes);
                    emoteList.forEach((emote, index) => {
                        setTimeout(() => {
                            const url = `https://static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/dark/3.0`;
                            spawnEmote(url);
                        }, index * SPAWN_INTERVAL);
                    });
                }
            };
            ws.onclose = () => { setTimeout(connectWebSocket, 5000); };
            ws.onerror = () => { ws.close(); };
        }

        connectWebSocket();
    </script>
</body>

</html>