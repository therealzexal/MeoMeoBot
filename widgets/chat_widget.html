<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Twitch Chat Overlay</title>
    <style>
        body {
            background: transparent;
            overflow: hidden;
            font-family: "Inter", "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            color: white;
        }

        #chat-container {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            height: 100vh;
            padding: 10px 10px 24px 10px;
            gap: 10px;
            box-sizing: border-box;
        }

        .msg-group {
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            animation: fadeIn 0.4s ease-out;
            word-wrap: break-word;
        }

        .msg-header {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }

        .msg-username {
            font-weight: 700;
        }

        .msg-badges {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .badge-img {
            width: 18px;
            height: 18px;
            object-fit: contain;
        }

        .msg-messages {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .msg-line {
            color: #e7eef5;
            line-height: 1.4;
        }

        .msg-line img {
            vertical-align: middle;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(8px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>

    <style>
        /* CUSTOM_CSS_PLACEHOLDER */
    </style>

</head>

<body>
    <div id="chat-container"></div>
    <script>
        const container = document.getElementById('chat-container');
        const MAX_MESSAGES = 10;
        const ALLOWED_BADGES = ['subscriber', 'moderator', 'vip', 'partner', 'staff', 'premium'];
        const CLIENT_ID = '__TWITCH_CLIENT_ID__';
        const APP_TOKEN = '__TWITCH_APP_TOKEN__';

        const globalBadgeMap = {};
        const channelBadgeCache = {};
        let globalBadgesLoaded = false;
        let globalBadgesPending = null;

        let ws, lastUser = null, lastGroup = null;
        const messageQueue = [];

        function sanitizeClass(str) {
            return String(str || '').toLowerCase().replace(/[^a-z0-9_-]+/g, '-').replace(/^-+|-+$/g, '') || 'user';
        }
        function computeColors(hexColor) {
            const fallback = '#6dd4ff';
            let c = (hexColor || '').trim();
            if (!/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(c)) c = fallback;
            if (c.length === 4) c = '#' + c[1] + c[1] + c[2] + c[2] + c[3] + c[3];
            const r = parseInt(c.slice(1, 3), 16), g = parseInt(c.slice(3, 5), 16), b = parseInt(c.slice(5, 7), 16);
            return { solid: c, soft: `rgba(${r}, ${g}, ${b}, 0.15)` };
        }
        function normalizeEmotes(emotes) {
            if (!emotes || typeof emotes !== 'object') return [];
            const parts = [];
            Object.keys(emotes).forEach(id => {
                emotes[id].forEach(r => {
                    if (typeof r === 'string') {
                        const [s, e] = r.split('-').map(n => parseInt(n, 10));
                        if (!Number.isNaN(s) && !Number.isNaN(e)) parts.push({ id, start: s, end: e });
                    } else if (r && typeof r === 'object' && Number.isInteger(r.start) && Number.isInteger(r.end)) {
                        parts.push({ id, start: r.start, end: r.end });
                    }
                });
            });
            parts.sort((a, b) => a.start - b.start);
            return parts;
        }
        function renderTextWithEmotes(text, emotesMap) {
            const frag = document.createDocumentFragment();
            const parts = normalizeEmotes(emotesMap);
            if (!parts.length) { frag.appendChild(document.createTextNode(text)); return frag; }
            let cursor = 0;
            for (const part of parts) {
                if (cursor < part.start) frag.appendChild(document.createTextNode(text.slice(cursor, part.start)));
                const emoteImg = document.createElement('img');
                emoteImg.src = `https://static-cdn.jtvnw.net/emoticons/v2/${part.id}/default/dark/1.0`;
                emoteImg.alt = text.slice(part.start, part.end + 1);
                emoteImg.style.verticalAlign = 'middle';
                frag.appendChild(emoteImg);
                cursor = part.end + 1;
            }
            if (cursor < text.length) frag.appendChild(document.createTextNode(text.slice(cursor)));
            return frag;
        }

        async function fetchHelixBadges(url) {
            if (!CLIENT_ID || !APP_TOKEN) throw new Error('Client ID ou App Access Token manquant pour lâ€™appel API.');
            const resp = await fetch(url, {
                headers: {
                    'Client-ID': CLIENT_ID,
                    'Authorization': `Bearer ${APP_TOKEN}`
                }
            });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            return resp.json();
        }

        async function ensureGlobalBadges() {
            if (globalBadgesLoaded) return;
            if (globalBadgesPending) { await globalBadgesPending; return; }
            globalBadgesPending = fetchHelixBadges('https://api.twitch.tv/helix/chat/badges/global')
                .then(data => {
                    const sets = (data && data.data) || [];
                    sets.forEach(set => {
                        const setId = set.set_id;
                        globalBadgeMap[setId] = globalBadgeMap[setId] || {};
                        (set.versions || []).forEach(v => {
                            globalBadgeMap[setId][v.id] = v.image_url_1x;
                        });
                    });
                    globalBadgesLoaded = true;
                })
                .catch(err => console.warn('[Badges] Global fetch failed', err))
                .finally(() => { globalBadgesPending = null; });
            await globalBadgesPending;
        }

        const channelBadgePromises = {};
        async function ensureChannelBadges(roomId) {
            if (!roomId) return;
            if (channelBadgeCache[roomId]) return;
            if (!channelBadgePromises[roomId]) {
                channelBadgePromises[roomId] = fetchHelixBadges(`https://api.twitch.tv/helix/chat/badges?broadcaster_id=${roomId}`)
                    .then(data => {
                        const map = {};
                        const sets = (data && data.data) || [];
                        sets.forEach(set => {
                            const setId = set.set_id;
                            (set.versions || []).forEach(v => {
                                map[`${setId}/${v.id}`] = v.image_url_1x;
                            });
                        });
                        channelBadgeCache[roomId] = map;
                    })
                    .catch(err => { console.warn('[Badges] Channel fetch failed', err); channelBadgeCache[roomId] = {}; });
            }
            await channelBadgePromises[roomId];
        }

        function parseBadgesRaw(badgesRaw) {
            if (!badgesRaw) return [];
            return badgesRaw.split(',')
                .map(entry => entry.trim())
                .filter(Boolean)
                .map(entry => {
                    const [set, version] = entry.split('/');
                    return set && version ? { set, version } : null;
                })
                .filter(Boolean)
                .filter(b => ALLOWED_BADGES.includes((b.set || '').toLowerCase()));
        }
        function parseBadgesObj(badgesObj) {
            if (!badgesObj || typeof badgesObj !== 'object') return [];
            return Object.entries(badgesObj)
                .map(([set, version]) => ({ set, version }))
                .filter(b => ALLOWED_BADGES.includes((b.set || '').toLowerCase()));
        }

        function createBadgeNode(entry, roomId) {
            const set = (entry.set || '').toLowerCase();
            const version = entry.version || '1';
            if (set === 'subscriber') {
                const map = channelBadgeCache[roomId];
                const url = map && map[`${set}/${version}`];
                if (url) {
                    const img = document.createElement('img');
                    img.className = 'badge-img';
                    img.alt = set;
                    img.src = url;
                    img.onerror = () => img.remove();
                    return img;
                }
                return null;
            }
            const versions = globalBadgeMap[set];
            const url = versions && versions[version];
            if (url) {
                const img = document.createElement('img');
                img.className = 'badge-img';
                img.alt = set;
                img.src = url;
                img.onerror = () => img.remove();
                return img;
            }
            return null;
        }

        function connectWebSocket() {
            const host = window.location.hostname;
            const port = new URL(document.URL).port;
            const wsUrl = `ws://${host}:${port}`;
            ws = new WebSocket(wsUrl);
            ws.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'chat') {
                    await ensureGlobalBadges();
                    if (data.roomId) await ensureChannelBadges(data.roomId);
                    addMessage(
                        data.username,
                        data.displayName || data.username,
                        data.text,
                        data.color,
                        data.badgesRaw || data.badges,
                        data.badgesObj || null,
                        data.emotes || null,
                        data.roomId || null
                    );
                }
            };
            ws.onclose = () => { setTimeout(connectWebSocket, 5000); };
            ws.onerror = () => { ws.close(); };
        }

        function addMessage(username, displayName, text, color, badgesRaw, badgesObj, emotes, roomId) {
            const userClass = sanitizeClass(username);
            const { solid, soft } = computeColors(color);

            let group = lastGroup;
            if (lastUser !== username || !group || !group.isConnected) {
                group = document.createElement('div');
                group.className = `msg-group user-${userClass}`;
                group.style.setProperty('--user-color', solid);
                group.style.setProperty('--user-color-soft', soft);

                const header = document.createElement('div');
                header.className = 'msg-header';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'msg-username';
                nameSpan.textContent = displayName || username;
                nameSpan.style.color = solid;

                const badgesWrap = document.createElement('span');
                badgesWrap.className = 'msg-badges';
                const seen = new Set();
                const badges = parseBadgesRaw(badgesRaw).concat(parseBadgesObj(badgesObj || {}));
                badges.forEach(entry => {
                    const key = `${entry.set}/${entry.version}`;
                    if (seen.has(key)) return;
                    const node = createBadgeNode(entry, roomId);
                    if (node) badgesWrap.appendChild(node);
                    seen.add(key);
                });

                header.appendChild(nameSpan);
                if (badgesWrap.children.length > 0) header.appendChild(badgesWrap);

                const messagesDiv = document.createElement('div');
                messagesDiv.className = 'msg-messages';

                group.appendChild(header);
                group.appendChild(messagesDiv);
                container.appendChild(group);

                lastGroup = group;
                lastUser = username;
            }

            const messagesDiv = group.querySelector('.msg-messages');
            const line = document.createElement('div');
            line.className = 'msg-line';
            line.appendChild(renderTextWithEmotes(text, emotes));
            messagesDiv.appendChild(line);

            messageQueue.push(line);
            while (messageQueue.length > MAX_MESSAGES) {
                const old = messageQueue.shift();
                const parent = old.parentElement;
                if (parent) {
                    parent.removeChild(old);
                    if (parent.children.length === 0) {
                        const grp = parent.parentElement;
                        if (grp) grp.remove();
                        if (grp === lastGroup) { lastGroup = null; lastUser = null; }
                    }
                }
            }
        }

        connectWebSocket();
    </script>
</body>

</html>