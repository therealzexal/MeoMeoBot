<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Chat Widget</title>
    <style id="base-css">
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            background-color: transparent;
            font-family: 'Inter', "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
        }

        #chat-container {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            height: 100vh;
            width: 100vw;
            padding: 20px;
            box-sizing: border-box;
        }

        #bg-video {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
        }
    </style>
    <style id="custom-css">
        /* __CUSTOM_CSS__ */
    </style>
</head>

<body>
    <video id="bg-video" loop autoplay muted playsinline>
        <source src="http://127.0.0.1:8087/widget/assets/pranax.webm" type="video/webm">
    </video>
    <div id="chat-container"></div>
    <script>
        const CLIENT_ID = '__TWITCH_CLIENT_ID__';
        const APP_TOKEN = '__TWITCH_APP_TOKEN__';

        const BADGE_PREFS = {};
        const globalBadgeMap = {};
        const channelBadgeCache = {};
        let globalBadgesLoaded = false;
        let globalBadgesPending = null;

        let ws,
            lastUser = null,
            lastGroup = null;
        let groupCounter = 0;
        const messageQueue = [];
        let MAX_MESSAGES = 10;

        const ALLOWED_BADGES = ['subscriber', 'moderator', 'vip', 'partner', 'staff', 'premium'];

        function sanitizeClass(str) {
            return String(str || '').toLowerCase().replace(/[^a-z0-9_-]+/g, '-').replace(/^-+|-+$/g, '') || 'user';
        }

        function computeColors(hexColor) {
            const fallback = '#6dd4ff';
            let c = (hexColor || '').trim();
            if (!/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(c)) c = fallback;
            if (c.length === 4) c = '#' + c[1] + c[1] + c[2] + c[2] + c[3] + c[3];
            const r = parseInt(c.slice(1, 3), 16),
                g = parseInt(c.slice(3, 5), 16),
                b = parseInt(c.slice(5, 7), 16);
            return {
                solid: c,
                soft: `rgba(${r}, ${g}, ${b}, 0.15)`
            };
        }

        function normalizeEmotes(emotes) {
            if (!emotes || typeof emotes !== 'object') return [];
            const parts = [];

            Object.keys(emotes).forEach(id => {
                emotes[id].forEach(r => {
                    if (typeof r === 'string') {
                        const [s, e] = r.split('-').map(n => parseInt(n, 10));
                        if (!Number.isNaN(s) && !Number.isNaN(e)) parts.push({
                            id, start: s, end: e
                        });
                    } else if (r && typeof r === 'object' && Number.isInteger(r.start) && Number.isInteger(r.end)) {
                        parts.push({
                            id, start: r.start, end: r.end
                        });
                    }
                });
            });
            parts.sort((a, b) => a.start - b.start);
            return parts;
        }

        function renderTextWithEmotes(text, emotesMap) {
            const frag = document.createDocumentFragment();
            const parts = normalizeEmotes(emotesMap);

            if (!parts.length) {
                frag.appendChild(document.createTextNode(text));
                return frag;
            }

            let cursor = 0;

            for (const part of parts) {
                if (cursor < part.start) frag.appendChild(document.createTextNode(text.slice(cursor, part.start)));
                const emoteImg = document.createElement('img');
                emoteImg.src = `https://static-cdn.jtvnw.net/emoticons/v2/${part.id}/default/dark/1.0`;
                emoteImg.alt = text.slice(part.start, part.end + 1);
                emoteImg.style.verticalAlign = 'middle';
                frag.appendChild(emoteImg);
                cursor = part.end + 1;
            }

            if (cursor < text.length) frag.appendChild(document.createTextNode(text.slice(cursor)));
            return frag;
        }

        async function fetchHelixBadges(url) {
            if (!CLIENT_ID || !APP_TOKEN) throw new Error('Client ID ou App Access Token manquant pour lâ€™appel API.');

            const resp = await fetch(url, {
                headers: {
                    'Client-ID': CLIENT_ID,
                    'Authorization': `Bearer ${APP_TOKEN}`
                }
            });

            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            return resp.json();
        }

        async function ensureGlobalBadges() {
            if (globalBadgesLoaded) return;
            if (globalBadgesPending) {
                await globalBadgesPending;
                return;
            }

            globalBadgesPending = fetchHelixBadges('https://api.twitch.tv/helix/chat/badges/global').then(data => {
                const sets = (data && data.data) || [];
                sets.forEach(set => {
                    const setId = set.set_id;
                    globalBadgeMap[setId] = globalBadgeMap[setId] || {};
                    (set.versions || []).forEach(v => {
                        globalBadgeMap[setId][v.id] = v.image_url_1x;
                    });
                });
                globalBadgesLoaded = true;
            }).catch(err => console.warn('[Badges] Global fetch failed', err)).finally(() => {
                globalBadgesPending = null;
            });
            await globalBadgesPending;
        }

        const channelBadgePromises = {};

        async function ensureChannelBadges(roomId) {
            if (!roomId) return;
            if (channelBadgeCache[roomId]) return;

            if (!channelBadgePromises[roomId]) {
                channelBadgePromises[roomId] = fetchHelixBadges(`https://api.twitch.tv/helix/chat/badges?broadcaster_id=${roomId}`)
                    .then(data => {
                        const map = {};
                        const sets = (data && data.data) || [];
                        sets.forEach(set => {
                            const setId = set.set_id;
                            (set.versions || []).forEach(v => {
                                map[`${setId}/${v.id}`] = v.image_url_1x;
                            });
                        });
                        channelBadgeCache[roomId] = map;
                    }).catch(err => {
                        console.warn('[Badges] Channel fetch failed', err);
                        channelBadgeCache[roomId] = {};
                    });
            }
            await channelBadgePromises[roomId];
        }

        function parseBadgesRaw(badgesRaw) {
            if (!badgesRaw) return [];
            return badgesRaw.split(',').map(entry => entry.trim()).filter(Boolean).map(entry => {
                const [set, version] = entry.split('/');
                return set && version ? { set, version } : null;
            }).filter(Boolean).filter(b => ALLOWED_BADGES.includes((b.set || '').toLowerCase()));
        }

        function parseBadgesObj(badgesObj) {
            if (!badgesObj || typeof badgesObj !== 'object') return [];
            return Object.entries(badgesObj).map(([set, version]) => ({
                set, version
            })).filter(b => ALLOWED_BADGES.includes((b.set || '').toLowerCase()));
        }

        function createBadgeNode(entry, roomId) {
            const set = (entry.set || '').toLowerCase();
            const version = entry.version || '1';

            if (BADGE_PREFS && BADGE_PREFS[set] === false) return null;

            if (set === 'subscriber') {
                const map = channelBadgeCache[roomId];
                const url = map && map[`${set}/${version}`];
                if (url) {
                    const img = document.createElement('img');
                    img.className = 'badge-img';
                    img.alt = set;
                    img.src = url;
                    img.onerror = () => img.remove();
                    return img;
                }
                return null;
            }

            const versions = globalBadgeMap[set];
            const url = versions && versions[version];
            if (url) {
                const img = document.createElement('img');
                img.className = 'badge-img';
                img.alt = set;
                img.src = url;
                img.onerror = () => img.remove();
                return img;
            }
            return null;
        }

        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:8087');

            ws.onopen = () => {
                console.log('Connected to Chat WebSocket');
                ws.send(JSON.stringify({ type: 'get-config' }));
            };

            ws.onmessage = async (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'config' || data.type === 'config-update') {
                        const cfg = data.config || data;

                        const bgVideo = document.getElementById('bg-video');
                        if (bgVideo) bgVideo.style.display = '';

                        document.getElementById('custom-css').textContent = cfg.customCSS || '';
                        requestAnimationFrame(() => updateSnow());

                        if (cfg.maxMessages) {
                            MAX_MESSAGES = parseInt(cfg.maxMessages, 10) || 10;
                        }
                    } else if (data.type === 'chat') {
                        await addMessage(data);
                    } else if (data.type === 'clear-chat') {
                        const container = document.getElementById('chat-container');
                        if (container) container.innerHTML = '';
                        lastUser = null;
                        lastGroup = null;
                        messageQueue.length = 0;
                    }
                } catch (e) {
                    console.error('WS Error:', e);
                }
            };

            ws.onclose = () => setTimeout(connectWebSocket, 3000);
            ws.onerror = (err) => console.error('WS Error:', err);
        }

        async function addMessage(msg) {
            const { username, displayName, color, badgesRaw, badges: badgesObj, text, emotes, roomId } = msg;

            ensureGlobalBadges();
            if (roomId) ensureChannelBadges(roomId);

            const colors = computeColors(color);
            const solid = colors.solid;
            const soft = colors.soft;

            const sameUser = (lastUser === username) && lastGroup;
            let group = lastGroup;
            const container = document.getElementById('chat-container');

            if (!sameUser) {
                group = document.createElement('div');
                const isEven = (groupCounter % 2) === 0;
                const variant = (groupCounter % 3) + 1;

                group.className = `msg-group user-${sanitizeClass(username)} group-${isEven ? 'even' : 'odd'} variant-${variant}`;
                groupCounter++;

                group.style.setProperty('--user-color', solid);
                group.style.setProperty('--user-color-soft', soft);

                const header = document.createElement('div');
                header.className = 'msg-header';

                const nameSpan = document.createElement('span');
                nameSpan.className = 'msg-username';
                nameSpan.textContent = displayName || username;
                nameSpan.style.color = solid;

                const badgesWrap = document.createElement('span');
                nameSpan.className = 'msg-badges';
                const seen = new Set();

                const badges = parseBadgesRaw(badgesRaw).concat(parseBadgesObj(badgesObj || {}));

                badges.forEach(entry => {
                    const key = `${entry.set}/${entry.version}`;
                    if (seen.has(key)) return;
                    const node = createBadgeNode(entry, roomId);
                    if (node) badgesWrap.appendChild(node);
                    seen.add(key);
                });

                header.appendChild(nameSpan);
                if (badgesWrap.children.length > 0) header.appendChild(badgesWrap);

                const messagesDiv = document.createElement('div');
                messagesDiv.className = 'msg-messages';

                group.appendChild(header);
                group.appendChild(messagesDiv);
                container.appendChild(group);

                lastGroup = group;
                lastUser = username;
            }

            const messagesDiv = group.querySelector('.msg-messages');
            const line = document.createElement('div');
            line.className = 'msg-line';
            line.appendChild(renderTextWithEmotes(text, emotes));
            messagesDiv.appendChild(line);

            messageQueue.push(line);

            while (messageQueue.length > MAX_MESSAGES) {
                const old = messageQueue.shift();
                const parent = old.parentElement;
                if (parent) {
                    parent.removeChild(old);
                    if (parent.children.length === 0) {
                        const grp = parent.parentElement;
                        if (grp) grp.remove();
                        if (grp === lastGroup) {
                            lastGroup = null;
                            lastUser = null;
                        }
                    }
                }
            }
        }

        function updateSnow() {
            const enable = getComputedStyle(document.body).getPropertyValue('--enable-snow').trim();
            let containerBg = document.getElementById('snow-container-bg');
            let containerFg = document.getElementById('snow-container-fg');

            if (enable === '1') {
                if (!containerBg) {
                    containerBg = document.createElement('div');
                    containerBg.id = 'snow-container-bg';
                    containerBg.style.position = 'absolute';
                    containerBg.style.top = '0';
                    containerBg.style.left = '0';
                    containerBg.style.width = '100%';
                    containerBg.style.height = '100%';
                    containerBg.style.pointerEvents = 'none';
                    containerBg.style.zIndex = '0';

                    for (let i = 0; i < 35; i++) {
                        const d = document.createElement('div');
                        d.className = 'snow';
                        containerBg.appendChild(d);
                    }
                    document.body.prepend(containerBg);

                    containerFg = document.createElement('div');
                    containerFg.id = 'snow-container-fg';
                    containerFg.style.position = 'absolute';
                    containerFg.style.top = '0';
                    containerFg.style.left = '0';
                    containerFg.style.width = '100%';
                    containerFg.style.height = '100%';
                    containerFg.style.pointerEvents = 'none';
                    containerFg.style.zIndex = '9999';

                    for (let i = 0; i < 15; i++) {
                        const d = document.createElement('div');
                        d.className = 'snow-fg';
                        containerFg.appendChild(d);
                    }
                    document.body.appendChild(containerFg);
                }
            } else {
                if (containerBg) containerBg.remove();
                if (containerFg) containerFg.remove();
            }
        }

        connectWebSocket();
    </script>
</body>

</html>