<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Twitch Chat Overlay</title>
    <style>
        body {
            background-color: transparent;
            overflow: hidden;
            font-family: "Inter", "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            color: white;
        }
        #chat-container {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            height: 100vh;
            padding: 10px 10px 24px 10px; /* padding bas pour éviter la coupe */
            gap: 10px;
            box-sizing: border-box;
        }
        .message {
            margin: 0;
            padding: 10px 12px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            animation: fadeIn 0.4s ease-out;
            word-wrap: break-word;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .message__meta {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
            flex-wrap: wrap;
        }
        .username {
            font-weight: 700;
            margin-right: 4px;
        }
        .message__body {
            color: #e7eef5;
            line-height: 1.4;
        }
        .badge-img {
            width: 18px;
            height: 18px;
            object-fit: contain;
        }
        .badge-chip {
            display: inline-flex;
            align-items: center;
            padding: 2px 6px;
            border-radius: 10px;
            background: var(--user-color-soft, rgba(255,255,255,0.12));
            color: var(--user-color, #fff);
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.3px;
            text-transform: uppercase;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to   { opacity: 1; transform: translateY(0); }
        }
    </style>

    <style>
/* CUSTOM_CSS_PLACEHOLDER */
    </style>

</head>
<body>
    <div id="chat-container"></div>

    <script>
        const container = document.getElementById('chat-container');
        const MAX_MESSAGES = 10;
        let ws;

        function sanitizeClass(str) {
            return String(str || '')
                .toLowerCase()
                .replace(/[^a-z0-9_-]+/g, '-')
                .replace(/^-+|-+$/g, '') || 'user';
        }

        function computeColors(hexColor) {
            const fallback = '#6dd4ff';
            let c = (hexColor || '').trim();
            if (!/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(c)) c = fallback;
            if (c.length === 4) {
                c = '#' + c[1] + c[1] + c[2] + c[2] + c[3] + c[3];
            }
            const r = parseInt(c.slice(1,3), 16);
            const g = parseInt(c.slice(3,5), 16);
            const b = parseInt(c.slice(5,7), 16);
            return {
                solid: c,
                soft: `rgba(${r}, ${g}, ${b}, 0.15)`
            };
        }

        function connectWebSocket() {
            const host = window.location.hostname;
            const port = new URL(document.URL).port;
            const wsUrl = `ws://${host}:${port}`;

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log("WebSocket connecté pour l'overlay.");
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'chat') {
                    addMessage(
                        data.username,
                        data.displayName || data.username,
                        data.text,
                        data.color,
                        data.badgesRaw || data.badges,
                        data.emotes || null
                    );
                }
            };

            ws.onclose = () => {
                console.log("WebSocket déconnecté. Tentative de reconnexion dans 5s...");
                setTimeout(connectWebSocket, 5000);
            };

            ws.onerror = (err) => {
                console.error("Erreur WebSocket:", err);
                ws.close();
            };
        }

            function parseBadgesRaw(badgesRaw) {
                if (!badgesRaw) return [];
                return badgesRaw.split(',')
                    .map(entry => entry.trim())
                    .filter(Boolean)
                    .map(entry => {
                        const [set, version] = entry.split('/');
                        return set && version ? { set, version } : null;
                    })
                    .filter(Boolean);
            }

        function createBadgeImg(entry) {
            const img = document.createElement('img');
            img.className = 'badge-img';
            img.alt = entry.set;
            img.src = `https://static-cdn.jtvnw.net/badges/v1/${entry.set}/${entry.version}/1`;
            img.onerror = () => img.remove();
            return img;
        }

        function emoteUrl(emoteId) {
         return `https://static-cdn.jtvnw.net/emoticons/v2/${emoteId}/default/dark/1.0`;
        }

        function renderTextWithEmotes(text, emotesMap) {
            const frag = document.createDocumentFragment();
            if (!emotesMap || typeof emotesMap !== 'object') {
                frag.appendChild(document.createTextNode(text));
                return frag;
            }
            // Construire les spans/emotes par positions
            const parts = [];
            Object.keys(emotesMap).forEach(id => {
                emotesMap[id].forEach(pos => {
                    parts.push({ id, start: pos.start, end: pos.end });
                });
            });
            parts.sort((a, b) => a.start - b.start);

            let cursor = 0;
            for (const part of parts) {
                if (cursor < part.start) {
                    frag.appendChild(document.createTextNode(text.slice(cursor, part.start)));
                }
                const emoteImg = document.createElement('img');
                emoteImg.src = emoteUrl(part.id);
                emoteImg.alt = text.slice(part.start, part.end + 1);
                emoteImg.style.verticalAlign = 'middle';
                frag.appendChild(emoteImg);
                cursor = part.end + 1;
            }
            if (cursor < text.length) {
                frag.appendChild(document.createTextNode(text.slice(cursor)));
            }
            return frag;
        }

        function addMessage(username, displayName, text, color, badgesRaw, emotes) {
        const msgElement = document.createElement('div');
        const userClass = sanitizeClass(username);
        const { solid, soft } = computeColors(color);

        msgElement.className = `message user-${userClass}`;
        msgElement.style.setProperty('--user-color', solid);
        msgElement.style.setProperty('--user-color-soft', soft);

        const metaRow = document.createElement('div');
        metaRow.className = 'message__meta';

        const userSpan = document.createElement('span');
        userSpan.className = 'username';
        userSpan.textContent = displayName || username;
        userSpan.style.color = solid;
        metaRow.appendChild(userSpan);

        parseBadgesRaw(badgesRaw).forEach(entry => {
            metaRow.appendChild(createBadgeImg(entry));
        });

        const body = document.createElement('div');
        body.className = 'message__body';
        body.appendChild(renderTextWithEmotes(text, emotes));

        msgElement.appendChild(metaRow);
        msgElement.appendChild(body);
        container.appendChild(msgElement);

        while (container.children.length > MAX_MESSAGES) {
            container.removeChild(container.children[0]);
        }
    }

        connectWebSocket();
    </script>
</body>
</html>
